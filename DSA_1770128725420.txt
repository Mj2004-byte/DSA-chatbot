## Arrays in JavaScript  
> **What they are** â€“ a *list* (ordered collection) of values.  
> **Why we use them** â€“ they let you store many items in one variable, loop over them, and use builtâ€‘in helpers that make everyday tasks a breeze.

---

### 1. Creating an Array

```js
// 1. Literal syntax â€“ most common
const fruits = ["apple", "banana", "cherry"];

// 2. Using the constructor (rare, but useful when you need a specific length)
const numbers = new Array(5);          // [ <5 empty items> ]
const zeros   = new Array(5).fill(0); // [0, 0, 0, 0, 0]
```

> **Tip**: Literal syntax (`[...]`) is preferred because itâ€™s shorter, clearer, and automatically creates a *dense* array (no holes).

---

### 2. Accessing & Updating Elements

```js
// Access the 2nd element (index 1)
console.log(fruits[1]);   // "banana"

// Update the 3rd element
fruits[2] = "strawberry";
console.log(fruits);      // ["apple", "banana", "strawberry"]
```

*Indexing starts at 0.*  
If you ask for an index that doesnâ€™t exist, youâ€™ll get `undefined` â€“ no crash, just a value that tells you â€œnothing is hereâ€.

```js
console.log(fruits[10]);  // undefined
```

---

### 3. Adding & Removing Items

| Operation | Method | Complexity | Notes |
|-----------|--------|------------|-------|
| Add to end | `push(value)` | **O(1)** amortized | Fastest way to grow an array |
| Remove from end | `pop()` | **O(1)** | |
| Add to front | `unshift(value)` | **O(n)** | Shifts all existing elements |
| Remove from front | `shift()` | **O(n)** | Shifts all existing elements |
| Insert at index | `splice(index, 0, value)` | **O(n)** | Same shifting cost |
| Remove at index | `splice(index, 1)` | **O(n)** | Same shifting cost |

```js
fruits.push("orange");         // ["apple","banana","strawberry","orange"]
fruits.pop();                  // removes "orange"
fruits.unshift("kiwi");        // ["kiwi","apple","banana","strawberry"]
fruits.shift();                // removes "kiwi"

fruits.splice(1, 0, "mango");  // insert at index 1
fruits.splice(2, 1);           // remove 1 element starting at index 2
```

> **Edge case**: `splice` can also remove *all* items (`splice(0)`) or add items without removal (`splice(2, 0, "mango")`).

---

### 4. Common Iteration Patterns

| Pattern | Example | Complexity |
|---------|---------|------------|
| `for` loop | `for (let i = 0; i < arr.length; i++) {}` | **O(n)** |
| `for...of` | `for (const v of arr) {}` | **O(n)** |
| `forEach` | `arr.forEach(v => console.log(v))` | **O(n)** |
| `map` | `const doubled = nums.map(v => v * 2)` | **O(n)** |
| `filter` | `const evens = nums.filter(v => v % 2 === 0)` | **O(n)** |
| `reduce` | `const sum = nums.reduce((a,b)=>a+b,0)` | **O(n)** |

```js
const numbers = [1, 2, 3, 4, 5];

// Traditional for
for (let i = 0; i < numbers.length; i++) {
  console.log(numbers[i] * 2); // 2,4,6,8,10
}

// for...of
for (const n of numbers) {
  console.log(n + 1); // 2,3,4,5,6
}

// forEach
numbers.forEach(n => console.log(n - 1)); // 0,1,2,3,4

// map
const squares = numbers.map(n => n * n);
console.log(squares); // [1,4,9,16,25]

// filter
const evens = numbers.filter(n => n % 2 === 0);
console.log(evens); // [2,4]

// reduce
const total = numbers.reduce((sum, n) => sum + n, 0);
console.log(total); // 15
```

> **Space Complexity**  
> `map`/`filter`/`reduce` create new arrays/values: **O(n)**.  
> `forEach` and `for...of` use **O(1)** extra space (only the loop variable).

---

### 5. Searching

| Method | Returns | Complexity |
|--------|---------|------------|
| `indexOf(value)` | First index or -1 | **O(n)** |
| `includes(value)` | `true/false` | **O(n)** |
| `find(predicate)` | First matching value or `undefined` | **O(n)** |
| `findIndex(predicate)` | Index or -1 | **O(n)** |

```js
const colors = ["red", "green", "blue", "green"];

console.log(colors.indexOf("green"));   // 1
console.log(colors.includes("yellow")); // false
console.log(colors.find(c => c === "blue")); // "blue"
console.log(colors.findIndex(c => c === "purple")); // -1
```

---

### 6. Sorting

```js
const nums = [4, 2, 9, 1, 5];

// Default sort turns values into strings â†’ bad for numbers
nums.sort(); // [1, 2, 4, 5, 9]  // works for numbers by accident
// Better: supply a compare function
nums.sort((a, b) => a - b); // numeric ascending
console.log(nums); // [1, 2, 4, 5, 9]
```

- **Complexity**: Varies with engine, but typically **O(nâ€¯logâ€¯n)** for most cases.  
- **Inâ€‘place**: `sort` mutates the original array â€“ if you need the old order, copy first: `const sorted = [...nums].sort((a,b)=>a-b);`

> **Edge case**: Sorting with custom compare can break if you return values other than `-1, 0, 1`.  

---

### 7. Multidimensional Arrays (Matrices)

```js
// 3x3 identity matrix
const identity = [
  [1, 0, 0],
  [0, 1, 0],
  [0, 0, 1],
];

// Access element at row 1, column 2
console.log(identity[1][2]); // 0

// Sum all elements
const sumAll = identity.flat().reduce((a,b)=>a+b,0);
console.log(sumAll); // 3
```

> **Tip**: `Array.prototype.flat()` (ES2019) flattens nested arrays, useful before reducing.

---

### 8. Edge Cases & Gotchas

| Problem | What happens | How to handle |
|---------|--------------|---------------|
| **Empty array** | Length = 0; any index access â†’ `undefined` | Check `arr.length > 0` before looping |
| **Outâ€‘ofâ€‘bounds index** | Returns `undefined` | Use `arr[index] !== undefined` |
| **Negative indices** | Treated as property name `"â€‘1"` â†’ `undefined` | No builtâ€‘in negative index support |
| **Sparse arrays** | Created with `new Array(n)` or `delete` | Theyâ€™re *holes* â€“ many methods skip holes (`forEach`, `map`) |
| **Large arrays** | Push/pop still fast, but sorting or searching is O(nâ€¯logâ€¯n) | Consider typed arrays (`Uint32Array`) for numeric data |
| **Array vs. Object** | Arrays have numeric indexes and `.length`; objects are key/value maps | Use `Array.isArray(value)` to be sure |

---

### 9. Quick â€œcheatâ€‘sheetâ€ of useful methods

| Method | What it does | Example |
|--------|--------------|---------|
| `push`, `pop` | End | `arr.push(10); arr.pop();` |
| `unshift`, `shift` | Start | `arr.unshift(0); arr.shift();` |
| `splice` | Insert/Remove | `arr.splice(2, 0, "x");` |
| `concat` | Combine two arrays | `[1,2].concat([3,4]);` |
| `slice` | Subâ€‘array | `arr.slice(1,3);` |
| `indexOf`, `includes` | Search | `arr.includes("apple")` |
| `find`, `findIndex` | Predicate | `arr.find(v=>v>5)` |
| `forEach`, `map`, `filter`, `reduce` | Iteration | `arr.map(v=>v*2)` |
| `sort`, `reverse` | Reorder | `arr.sort()` |

---

### 10. Recap in 3 Lines

```js
const arr = [1, 2, 3];   // 1ï¸âƒ£ create
arr.push(4);             // 2ï¸âƒ£ mutate (add)
console.log(arr.map(x => x*2)); // 3ï¸âƒ£ iterate and transform
```

---

## Final Thought

Arrays are your best friend when you need an ordered, indexâ€‘addressable collection.  
- Use `push/pop` for stackâ€‘like behavior.  
- Use `shift/unshift` sparingly (theyâ€™re expensive).  
- Take advantage of builtâ€‘in iteration methods for cleaner, more readable code.  

Keep an eye on complexity: most array operations are linear, but `push/pop` are constantâ€‘time.  

Happy coding! ğŸš€ If you run into a tricky scenario, just let me knowâ€”Iâ€™m here to help.